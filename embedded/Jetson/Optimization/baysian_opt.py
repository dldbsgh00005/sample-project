from skopt import gp_minimize

# 1. 초기 데이터: 이미 수집한 PID 계수와 성능(여기서는 alignment_time) 데이터
#    x0: 각 데이터 행은 [pid_x_Kp, pid_x_Ki, pid_x_Kd, pid_rotation_Kp, pid_rotation_Ki, pid_rotation_Kd, pid_speed_Kp, pid_speed_Ki, pid_speed_Kd] 형태
#    y0: 각 데이터 행에 대응하는 alignment_time 값
x0 = [
    [0.07,0.015,0.005,0.06,0.012,0.004,0.025,0.008,0.002],
    [0.07,0.015,0.005,0.06,0.012,0.004,0.025,0.008,0.002],
    [0.07,0.015,0.005,0.06,0.012,0.004,0.025,0.008,0.002],
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018],
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018],
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018],
    [0.08,0.017,0.006,0.07,0.014,0.005,0.03,0.009,0.0025],
    [0.08,0.017,0.006,0.07,0.014,0.005,0.03,0.009,0.0025],
    [0.08,0.017,0.006,0.07,0.014,0.005,0.03,0.009,0.0025],
    [0.07,0.015,0.003,0.06,0.012,0.003,0.025,0.008,0.0015],
    [0.07,0.015,0.003,0.06,0.012,0.003,0.025,0.008,0.0015],
    [0.07,0.015,0.003,0.06,0.012,0.003,0.025,0.008,0.0015],
    [0.07,0.02,0.005,0.06,0.018,0.004,0.025,0.01,0.002],
    [0.07,0.02,0.005,0.06,0.018,0.004,0.025,0.01,0.002],
    [0.07,0.02,0.005,0.06,0.018,0.004,0.025,0.01,0.002],
    [0.07,0.01,0.005,0.06,0.008,0.004,0.025,0.005,0.002],
    [0.07,0.01,0.005,0.06,0.008,0.004,0.025,0.005,0.002],
    [0.07,0.01,0.005,0.06,0.008,0.004,0.025,0.005,0.002],
    [0.07,0.015,0.007,0.06,0.012,0.006,0.025,0.008,0.003],
    [0.07,0.015,0.007,0.06,0.012,0.006,0.025,0.008,0.003],
    [0.09,0.02,0.01,0.08,0.018,0.008,0.035,0.01,0.004],
    [0.07,0.015,0.007,0.06,0.012,0.006,0.025,0.008,0.003], 
    [0.07,0.015,0.007,0.06,0.012,0.006,0.025,0.008,0.003], 
    [0.09,0.02,0.01,0.08,0.018,0.008,0.035,0.01,0.004], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018],
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], 
    [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018], [0.06,0.013,0.004,0.055,0.011,0.0035,0.022,0.007,0.0018]

    # ... 추가 데이터들
]
y0 = [
    20.226991415023804,
    22.767025470733643,
    21.387027978897095,
    22.45142936706543,
    21.659995079040527,
    23.22264337539673,
    22.062779426574707,
    28.331351280212402,
    21.648762702941895,
    21.551751375198364,
    26.012306690216064,
    24.108768939971924,
    25.143792152404785,
    20.67754054069519,
    23.877315521240234,
    22.583564281463623,
    21.012878894805908,
    22.07300305366516,
    20.949685096740723,
    22.5185763835907,
    25.181455612182617,
    20.949685096740723,
    22.5185763835907,
    25.181455612182617,
    35.538029193878174,
    25.56729221343994,
    19.661871671676636,
    23.748646020889282,
    40.75521969795227,
    9.991628646850586,
    23.164759159088135,
    28.67288565635681,
    18.934208393096924,
    18.544878721237183,
    15.315048456192017,
    17.166727304458618,
    16.902079343795776,
    15.231140613555908,
    17.276038885116577,
    16.771929264068604,
    21.66642737388611,
    15.371830940246582,
    22.146759510040283,
    14.639952898025513,
    15.695396661758423,
    25.03774905204773,
    22.17374014854431,
    15.830904245376587,
    21.331576347351074,
    16.470361709594727,
    15.374237537384033,
    26.16571855545044,
    17.7954318523407,
    11.836743593215942,
    12.34226393699646,

    # ... 추가 성능 데이터들
]

# 2. 탐색 공간 정의: 각 PID 계수에 대해 실험할 범위를 지정
dimensions = [
    (0.05, 0.09),    # pid_x Kp
    (0.01, 0.02),    # pid_x Ki
    (0.003, 0.01),   # pid_x Kd
    (0.045, 0.08),   # pid_rotation Kp
    (0.008, 0.018),  # pid_rotation Ki
    (0.003, 0.008),  # pid_rotation Kd
    (0.02, 0.035),   # pid_speed Kp
    (0.005, 0.010),  # pid_speed Ki
    (0.0015, 0.004)  # pid_speed Kd
]

# 3. 베이지안 최적화 실행: 추가로 20회의 실험 포인트를 추천받음
#    func: 여기서는 이미 데이터를 warm start 했으므로 dummy 함수를 사용(실제 사용 시 objective 함수를 정의)
res = gp_minimize(
    func=lambda params: 0,  # 더 이상 사용되지 않는 dummy objective 함수
    dimensions=dimensions,
    n_calls=30,             # 10번의 평가로 최적 후보 추천
    x0=x0,                  # 기존 파라미터 조합 데이터
    y0=y0,                  # 기존 성능 평가 데이터
    random_state=42         # 결과 재현성을 위한 random state
)

# 4. 최적화 결과 출력: res.x는 AI가 제시한 새로운 실험 포인트(즉, PID 계수 조합)
print("AI가 제안한 새로운 PID 계수 세트:", res.x)

# ------------------------------------------------------------
# 5. 새로운 포인트를 실제 실험 또는 시뮬레이션에 적용하여 성능 데이터를 수집합니다.
#
# 예를 들어, 새로운 포인트가 res.x 라고 하면:
# new_x = res.x
#
# 실제 실험을 통해 이 새로운 PID 계수 조합에 대한 성능(예: alignment_time)을 측정하고,
# 그 측정값을 new_y라 가정합시다.
#
# 예시:
# new_y = 19.5  # 측정된 성능값 (alignment_time)
#
# 6. 기존 데이터 업데이트:
#    x0.append(new_x)
#    y0.append(new_y)
#
# 7. 업데이트된 x0, y0 데이터를 기반으로 위의 gp_minimize 코드를 다시 실행하여 모델을 업데이트하고,
#    최적의 PID 계수를 점차 찾아가는 과정을 반복합니다.
#
# 이렇게 반복적인 실험과 최적화 과정을 통해 최종적으로 최적화된 PID 계수를 찾을 수 있습니다.
